; MINIMON - Shared Ram Control Program for trs-80 1k dual port RAM at 3000horg 0x3000; Commands are entered by setting the [control register] to:; 0 - do nothing and exit immediately, as if returning from a keyboard call (normal trs-80 operation); 1 - keep locked in loader program loop (normal operation when using MINIMON); 2 - read byte at address stored in [address register] to [data register]; 3 - write byte stored in [data register] to address stored in [address register]start:	ld (stackBack),sp  ;save existing stack location	ld sp,controlReg   ;start local stack at bottom 	push bc	push de	push hl	ld de,4015h ;get keypress	call 0013h	ld (inKey),a		call dispScreenOnLEDs		;check lock into trsterm loop by keypress (shift+@)	;ld a,(3801h)    ;ld d,a    ;ld a,(3880h)	;and d    ;cp 01h ;compare with 0b00000001	;jp z,trsterment	main:	;LD a,(4040h) ;display clock/timer on debug display. This will only update if interrupts are enabled.	;out (0b6h),a	ld A,(controlReg)	cp 0	JP Z,exit        ;command 0	DEC A	DEC A	JP Z,read        ;command 2	DEC A	JP Z,write       ;command 3	DEC A	JP Z,exitKey     ;4	JP main	;trsterment:;	jr mainposSet: ;positivly sets memory at hl with value of a	ld d,a	posSet2:	ld a,d	ld (hl),a	ld a,(hl)	cp d	ret z 	jp posSet2read:	ld de,(addressReg)	ld a,(de)	ld (dataReg),a	ld a,1	ld hl,controlReg	call posSet	jr mainwrite:	ld de,(addressReg)	ld a,(dataReg)	ld (de),a	;out (0bdh),a 	;out (0b6h),a	ld a,1	ld hl,controlReg	call posSet	jp mainexit: ;load orignal stack pointer and return with keypress from keyboard	;control reg is already zero	ld a,(inKey)	pop hl	pop de	pop bc	ld sp,(stackBack)	retexitKey: ;load orignal stack pointer and return with keypress from data register	ld a,0	ld hl,controlReg	call posSet	ld a,(dataReg)	pop hl	pop de	pop bc	ld sp,(stackBack)	ret	disphex: ;display hex value in A on screen at location DE	push bc	ld b,a	ld c,a	sra c	sra c	sra c	sra c	ld a,0x0f	and c	call disphexascii	ld (de),a	inc de	ld a,0x0f	and b	call disphexascii	ld (de),a	pop bc	retdisphexascii: ;makes 4 lower bits in A to ascii 0-f	add a,48	cp 58	jr nc,disphexasciif	disphexasciifret:	ret	disphexasciif: ;for characters A-F	add a,7	jr disphexasciifretdispScreenOnLEDs: ;16 characters on the last line of the screen, on the DSKY LEDs.				  ;use the arrow keys on DSKY to move window around	ld hl,(screenDispPointer)		call getDskyKey ;look to see if a dsky key is pressed	cp 255	jr nz,dispScreenCont1	ld (dispScreenKeyStore),a ;a==255		dispScreenCont1:		ld b,a		ld a,(dispScreenKeyStore) ;skip key press stuff if a key was not last released		cp 255		jr nz, dispScreenDisp		ld a,b			ld (dispScreenKeyStore),a		cp 2		call z,dispScreenDown		cp 4		call z,dispScreenLeft		cp 8		call z,dispScreenUp		cp 6		call z,dispScreenRight		cp 5		call z,dispScreenRestore		ld (screenDispPointer),hl		;part that actally reads from screen memory	dispScreenDisp:		ld c,0x70		ld b,16 ;loop 16 times		dispScreenOnLEDsLoop:		dec c		ld a,(hl)		cp 32		jp nc,dispScreenOnLEDs1		;set bit 6 so trs-80 characters 0-31 will show as ascii 64-95		or 0x40		dispScreenOnLEDs1:		out (c),a		inc hl		dec b		jp nz,dispScreenOnLEDsLoop		ret		dispScreenDown:		xor a		ld bc,0x0040		adc hl,bc		ret	dispScreenUp:		xor a		ld bc,0x0040		sbc hl,bc		ret	dispScreenLeft:		xor a		ld bc,0x0010		sbc hl,bc		ret	dispScreenRight:		xor a		ld bc,0x0010		adc hl,bc		ret	dispScreenRestore:		ld hl,0x3c00		ret		;borrowed from dskymon; compactify later	getDskyKey: ;returns A with key scancode (or 255 and z if no key pressed)	push bc	push de	ld e,0	ld d,1 ;will rotate to bit 0 in a moment	getDskyKey_Col: ;read col at address c and return a	ld a,0x60	add a,d	rlc d      ;generates 1,2,4,8 (the columns)	ld c,a	in a,(c) ;read col address	ld c,a	ld b,6	getDskyKey_loop1:	ld a,1	and c	push af	rrc c	pop af	jr z, getDskyKeyCols_B 	djnz getDskyKey_loop1	;nothing found	ld a,255	jr getDskyKeyCols_X	getDskyKeyCols_B: ;something found	ld a,b	getDskyKeyCols_X: ;	;a is col keyboard scan code here (or 255 if not pressed)	cp 255 ;check if no key was pressed	ld b,a	jr nz,getDskyKeyCols_Y	ld a,d	cp 16	jr z,getDskyKey_Z	ld b,a	ld a,6	add a,e	ld e,a	jr getDskyKey_Col	getDskyKeyCols_Y: ;some key was pressed (get ready to return)	;b has col scan	ld a,b	add a,e	push hl	ld hl,dskyKeyLUT ;lookup table base address	ld b,0	dec a	ld c,a	add hl,bc ;offset in LUT	ld a,(hl) ;content of LUT	pop hl	jr getDskyKey_Exit	getDskyKey_Z:	;no key pressed	ld a,255	getDskyKey_Exit:	cp 255 ;if nokey	pop de	pop bc	ret	dskyKeyLUT:	DB "M"  ;M	DB 0x0A ;A	DB 0x07 ;7	DB 0x04 ;4	DB 0x01 ;1	DB 0x00 ;0	DB "I"  ;I	DB 0x0B ;B	DB 0x08 ;8	DB 0x05 ;5	DB 0x02 ;2	DB "(" ;LEFT	DB "J"  ;J	DB 0x0C ;C	DB 0x09 ;9	DB 0x06 ;6	DB 0x03 ;3	DB ")" ;RIGHT	DB "K"  ;K	DB 0x0D ;D	DB 0x0E ;E	DB 0x0F ;F	DB "V"  ;V	DB "X"  ;Xseek 0x03F0org 0x33f0;dataArea (starts at 0x33f0)controlReg:db 0x00dataReg:db 0x00addressReg:db 0x00db 0x00trs80Key:db 0x00stackBack:db 0x00db 0x00inKey:db 0x00screenDispPointer:db 0x00db 0x3cdispScreenKeyStore:db 0x00 ;is not 255 when a dsky key is still held;extrasdb 0x00db 0x00db 0x00