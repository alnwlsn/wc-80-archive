; MINIMON - Shared Ram Control Program for trs-80 1k dual port RAM at 3000horg 0x3000; Commands are entered by setting the [control register] to:; 0 - do nothing and exit immediately, as if returning from a keyboard call (normal trs-80 operation); 1 - keep locked in loader program loop (normal operation when using MINIMON); 2 - read byte at address stored in [address register] to [data register]; 3 - write byte stored in [data register] to address stored in [address register]start:	ld (stackBack),sp  ;save existing stack location	ld sp,programEnd   ;start local stack at end of program		push bc	push de	push hl	ld de,4015h ;get keypress	call 0013h	ld (inKey),a		call dispScreenOnLEDs		;check lock into trsterm loop by keypress (shift+@)	;ld a,(3801h)    ;ld d,a    ;ld a,(3880h)	;and d    ;cp 01h ;compare with 0b00000001	;jp z,trsterment	main:	;LD a,(4040h) ;display clock/timer on debug display. This will only update if interrupts are enabled.	;out (0b6h),a	ld A,(controlReg)	cp 0	JP Z,exit        ;command 0	DEC A	DEC A	JP Z,read        ;command 2	DEC A	JP Z,write       ;command 3	DEC A	JP Z,exitKey     ;4	JP main	;trsterment:;	jr mainposSet: ;positivly sets memory at hl with value of a	ld d,a	posSet2:	ld a,d	ld (hl),a	ld a,(hl)	cp d	ret z 	jp posSet2read:	ld de,(addressReg)	ld a,(de)	ld (dataReg),a	ld a,1	ld hl,controlReg	call posSet	jr mainwrite:	ld de,(addressReg)	ld a,(dataReg)	ld (de),a	;out (0bdh),a	;out (0b6h),a	ld a,1	ld hl,controlReg	call posSet	jp mainexit: ;load orignal stack pointer and return with keypress from keyboard	;control reg is already zero	ld a,(inKey)	pop hl	pop de	pop bc	ld sp,(stackBack)	retexitKey: ;load orignal stack pointer and return with keypress from data register	ld a,0	ld hl,controlReg	call posSet	ld a,(dataReg)	pop hl	pop de	pop bc	ld sp,(stackBack)	ret	dispScreenOnLEDs: ;displays the first 16 characters on the last line of the screen, on the DSKY LEDs.	ld hl,0x3fc0	ld a,(0x3880)	and 0x80	jp z,dispScreenOnLEDs2	;special key (any) was pressed, so scroll up a line (just one, it's all we got)	ld hl,0x3f80	dispScreenOnLEDs2:	ld c,0x70	ld b,16 ;loop 16 times	dispScreenOnLEDsLoop:	dec c	ld a,(hl)	cp 32	jp nc,dispScreenOnLEDs1	;set bit 6 so trs-80 characters 0-31 will show as ascii 64-95	or 0x40	dispScreenOnLEDs1:	out (c),a	inc hl	dec b	jp nz,dispScreenOnLEDsLoop	ret	disphex: ;display hex value in A on screen at location DE	push bc	ld b,a	ld c,a	sra c	sra c	sra c	sra c	ld a,0x0f	and c	call disphexascii	ld (de),a	inc de	ld a,0x0f	and b	call disphexascii	ld (de),a	pop bc	retdisphexascii: ;makes 4 lower bits in A to ascii 0-f	add a,48	cp 58	jr nc,disphexasciif	disphexasciifret:	ret	disphexasciif: ;for characters A-F	add a,7	jr disphexasciifret	programEnd:seek 0x03F0org 0x33f0;dataArea (starts at 0x33f0)controlReg:db 0x00dataReg:db 0x00addressReg:db 0x00db 0x00trs80Key:db 0x00stackBack:db 0x00db 0x00inKey:db 0x00;extrasdb 0x00db 0x00db 0x00db 0x00db 0x00db 0x00