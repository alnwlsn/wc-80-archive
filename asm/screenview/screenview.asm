; SCREENVIEW - hijacks the heartbeat interrupt to display the trs-80 screen on the bubble ledsorg 0x3400start:	di	push af	push bc	push de	push hl		call dispScreenOnLEDs		pop hl	pop de	pop bc	pop af		jp 0x4012 ;continue with interrupt stuff here (which is where we came from)	disphex: ;display hex value in A on screen at location DE	push bc	ld b,a	ld c,a	sra c	sra c	sra c	sra c	ld a,0x0f	and c	call disphexascii	ld (de),a	inc de	ld a,0x0f	and b	call disphexascii	ld (de),a	pop bc	retdisphexascii: ;makes 4 lower bits in A to ascii 0-f	add a,48	cp 58	jr nc,disphexasciif	disphexasciifret:	ret	disphexasciif: ;for characters A-F	add a,7	jr disphexasciifretdispScreenOnLEDs: ;16 characters on the last line of the screen, on the DSKY LEDs.				  ;use the arrow keys on DSKY to move window around	ld hl,(screenDispPointer)		call getDskyKey ;look to see if a dsky key is pressed	cp 255	jr nz,dispScreenCont1	ld (dispScreenKeyStore),a ;a==255		dispScreenCont1:		ld b,a		ld a,(dispScreenKeyStore) ;skip key press stuff if a key was not last released		cp 255		jr nz, dispScreenDisp		ld a,b			ld (dispScreenKeyStore),a		cp 2		call z,dispScreenDown		cp 4		call z,dispScreenLeft		cp 8		call z,dispScreenUp		cp 6		call z,dispScreenRight		cp 5		call z,dispScreenRestore		ld (screenDispPointer),hl		;part that actally reads from screen memory	dispScreenDisp:		ld c,0x70		ld b,16 ;loop 16 times		dispScreenOnLEDsLoop:		dec c		ld a,(hl)		cp 32		jp nc,dispScreenOnLEDs1		;set bit 6 so trs-80 characters 0-31 will show as ascii 64-95		or 0x40		dispScreenOnLEDs1:		out (c),a		inc hl		dec b		jp nz,dispScreenOnLEDsLoop		ret		dispScreenDown:		xor a		ld bc,0x0040		adc hl,bc		ret	dispScreenUp:		xor a		ld bc,0x0040		sbc hl,bc		ret	dispScreenLeft:		xor a		ld bc,0x0010		sbc hl,bc		ret	dispScreenRight:		xor a		ld bc,0x0010		adc hl,bc		ret	dispScreenRestore:		ld hl,0x3c00		ret		;borrowed from dskymon; compactify later	getDskyKey: ;returns A with key scancode (or 255 and z if no key pressed)	push bc	push de	ld e,0	ld d,1 ;will rotate to bit 0 in a moment	getDskyKey_Col: ;read col at address c and return a	ld a,0x60	add a,d	rlc d      ;generates 1,2,4,8 (the columns)	ld c,a	in a,(c) ;read col address	ld c,a	ld b,6	getDskyKey_loop1:	ld a,1	and c	push af	rrc c	pop af	jr z, getDskyKeyCols_B 	djnz getDskyKey_loop1	;nothing found	ld a,255	jr getDskyKeyCols_X	getDskyKeyCols_B: ;something found	ld a,b	getDskyKeyCols_X: ;	;a is col keyboard scan code here (or 255 if not pressed)	cp 255 ;check if no key was pressed	ld b,a	jr nz,getDskyKeyCols_Y	ld a,d	cp 16	jr z,getDskyKey_Z	ld b,a	ld a,6	add a,e	ld e,a	jr getDskyKey_Col	getDskyKeyCols_Y: ;some key was pressed (get ready to return)	;b has col scan	ld a,b	add a,e	push hl	ld hl,dskyKeyLUT ;lookup table base address	ld b,0	dec a	ld c,a	add hl,bc ;offset in LUT	ld a,(hl) ;content of LUT	pop hl	jr getDskyKey_Exit	getDskyKey_Z:	;no key pressed	ld a,255	getDskyKey_Exit:	cp 255 ;if nokey	pop de	pop bc	ret	dskyKeyLUT:	DB "M"  ;M	DB 0x0A ;A	DB 0x07 ;7	DB 0x04 ;4	DB 0x01 ;1	DB 0x00 ;0	DB "I"  ;I	DB 0x0B ;B	DB 0x08 ;8	DB 0x05 ;5	DB 0x02 ;2	DB "(" ;LEFT	DB "J"  ;J	DB 0x0C ;C	DB 0x09 ;9	DB 0x06 ;6	DB 0x03 ;3	DB ")" ;RIGHT	DB "K"  ;K	DB 0x0D ;D	DB 0x0E ;E	DB 0x0F ;F	DB "V"  ;V	DB "X"  ;X;dataArea (which we can do because this is in ram)dataReg:db 0x00addressReg:db 0x00db 0x00trs80Key:db 0x00stackBack:db 0x00db 0x00inKey:db 0x00screenDispPointer:db 0x00db 0x3cdispScreenKeyStore:db 0x00 ;is not 255 when a dsky key is still held